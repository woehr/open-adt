-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Open algebraic data types.
--   
--   This library, built upon row-types, provides types and functions for
--   variants of various functors that all have the same type applied to
--   them. This is very similar to, and inspired by,
--   <a>haskus-utils-variant</a>. At the time of writing, the compile-time
--   performance of haskus-utils-variant is poor for variants with many
--   fields, which should be improved in this package by using row-types.
--   
--   The main types of interest in this package are <a>VarF</a> and
--   <a>OpenADT</a>. <a>VarF</a> wraps a variant of functors, all over the
--   same type, and provides a functor instance that fmaps over whatever
--   the variant is. <a>OpenADT</a> is the fixed-point type of <a>VarF</a>,
--   which allows for recursive structures to be created.
--   
--   A convenience function, <a>mkVarPattern</a> from
--   <a>Data.OpenADT.TH</a>, generates patterns that can be used as
--   constructors for variants. The key aspect of these patterns is that
--   they are polymorphic in the type of the row, allowing them to be used
--   as constructors for any open algebraic data type that includes a
--   particular constructor.
--   
--   For examples, see the <a>Data.OpenADT.Tutorial</a> module.
@package open-adt
@version 1.0


-- | This module defines the <a>VarF</a> type and related functions and
--   instances. This type wraps a variant of types that have all had the
--   same type applied to them. Most often this will be a variant
--   constructed with a row of functors.
module Data.OpenADT.VarF

-- | Apply a type to a <a>Row</a>.

-- | Apply a type to each element of an <a>LT</a>.

-- | A newtype that wraps a variant. The variant is a row made up of <b>(*
--   -&gt; *)</b> that all have the type <b>x</b> applied to them with
--   <a>ApplyRow</a>.
newtype VarF (r :: Row (* -> *)) x
VarF :: Var (ApplyRow x r) -> VarF x
[unVarF] :: VarF x -> Var (ApplyRow x r)

-- | A helper for writing functions with <a>metamorph'</a>. This type
--   reverses the argument order of <a>VarF</a> so the <a>Row</a> parameter
--   is last.
newtype VarF' x (r :: Row (* -> *))
VarF' :: Var (ApplyRow x r) -> VarF' x
[unVarF'] :: VarF' x -> Var (ApplyRow x r)

-- | A helper for writing functions with <a>metamorph'</a>. This type wraps
--   an <b>f a</b> but takes the type arguments in the order <b>a f</b>.
newtype FlipApp (a :: *) (f :: * -> *)
FlipApp :: (f a) -> FlipApp

-- | Apply a function to the variant within a <a>VarF</a>.
mapVarF :: (Var (ApplyRow x u) -> Var (ApplyRow x v)) -> VarF u x -> VarF v x

-- | This function is useful for implementing functions that are used as
--   catamorphisms, and sometimes <a>VarF</a> instances. The function
--   applies its first argument to whatever variant is wrapped by <b>VarF r
--   x</b> provided all elements of the row <b>r</b> are constrained by
--   <b>c</b>.
--   
--   For an example, see the <a>Show1</a> instance implementation.
varFAlg :: forall (c :: (* -> *) -> Constraint) (r :: Row (* -> *)) (x :: *) (y :: *). (Forall r c) => (forall f. (c f) => f x -> y) -> VarF r x -> y

-- | The same as <a>varFAlg</a>, but with the constraint fixed to
--   <a>Unconstrained1</a>.
varFAlg' :: forall (r :: Row (* -> *)) (x :: *) (y :: *). (Forall r Unconstrained1) => (forall f. (Unconstrained1 f) => f x -> y) -> VarF r x -> y

-- | RowFromTo fs b := for (l,a) in fs; SUM [ l :-&gt; (a -&gt; b) ]

-- | <a>RowFromTo</a> over a list of <a>LT</a>.

-- | Given a record of functions, use those functions to remove the
--   corresponding rows from the input. Type errors will ensue if the
--   record contains fields of the output variant.
reduceVarF :: forall r s t x r' s' t'. (t ≈ r .\\ s, r' ~ ApplyRow x r, s' ~ ApplyRow x s, s' ≈ r' .\\ t', t' ≈ r' .\\ s', Disjoint s' t', Switch t' (RowFromTo t' (VarF s x)) (VarF s x)) => Rec (RowFromTo t' (VarF s x)) -> VarF r x -> VarF s x

-- | A type constraint synonym for convenience that can be used in, for
--   example, patterns. The variables <b>r</b> (representing a Row) and
--   <b>v</b> (representing the type applied to <b>f</b>) are generally
--   left abstract. The variable <b>l</b> is the label corresponding to
--   <b>f v</b>.
--   
--   The order of variables are in the same order as the equality
--   constraint in the synonym, making it easy to remember.
type OpenAlg r l f v = (ApplyRow v r .! l ≈ f v, AllUniqueLabels (ApplyRow v r))
instance Data.Row.Internal.Forall (Data.OpenADT.VarF.ApplyRow x r) GHC.Classes.Eq => GHC.Classes.Eq (Data.OpenADT.VarF.VarF r x)
instance Data.Row.Internal.Forall (Data.OpenADT.VarF.ApplyRow x r) GHC.Show.Show => GHC.Show.Show (Data.OpenADT.VarF.VarF r x)
instance Data.Row.Internal.Forall r GHC.Base.Functor => GHC.Base.Functor (Data.OpenADT.VarF.VarF r)
instance Data.Row.Internal.Forall r Data.Functor.Classes.Eq1 => Data.Functor.Classes.Eq1 (Data.OpenADT.VarF.VarF r)
instance Data.Row.Internal.Forall r Data.Functor.Classes.Show1 => Data.Functor.Classes.Show1 (Data.OpenADT.VarF.VarF r)


-- | This module exports template haskell functions for generating tedious
--   boilerplate.
module Data.OpenADT.TH

-- | Create patterns for a variant constructor.
--   
--   For example, for the type FooF with the constructor FooF':
--   
--   <pre>
--   data FooF a x = FooF' a x
--   $(mkVarPattern ''FooF "foo" "Foo" "FooF")
--   </pre>
--   
--   A pattern similar to the following will be generated:
--   
--   <pre>
--   pattern FooF :: (OpenAlg r "foo" (FooF a) v) =&gt; a -&gt; v -&gt; VarF r v
--   pattern FooF a v &lt;- VarF (view (Label :: Label "foo") -&gt; Just (FooF' a v))
--   
--   pattern Foo :: (OpenAlg r "foo" (FooF a) (OpenADT r))
--               =&gt; a -&gt; OpenADT r -&gt; OpenADT r
--     where FooF a v = VarF (IsJust (Label :: Label "foo") (FooF' a v))
--   pattern Foo  a v = Fix (FooF a v)
--   </pre>
mkVarPattern :: Name -> String -> String -> String -> Q [Dec]


-- | This module lifts functions from row-types on <a>Var</a> to the
--   <a>VarF</a> type. All functions in this module are named as their
--   row-types version with an <b>F</b> appended.
module Data.OpenADT.VariantsF

-- | Like <a>diversify</a> but specialised for <a>VarF</a>.
diversifyF :: forall r' x r. (ApplyRow x r .\/ ApplyRow x r' ≈ ApplyRow x (r .\/ r')) => VarF r x -> VarF (r .\/ r') x

-- | Like <a>trial</a> but specialised for <a>VarF</a>.
trialF :: (ApplyRow x r .- l ≈ ApplyRow x (r .- l), KnownSymbol l) => VarF r x -> Label l -> Either (ApplyRow x r .! l) (VarF (r .- l) x)

-- | Like <a>multiTrial</a> but specialised for <a>VarF</a>.
multiTrialF :: forall u v x. (ApplyRow x v .\\ ApplyRow x u ≈ ApplyRow x (v .\\ u), AllUniqueLabels (ApplyRow x u), Forall (ApplyRow x (v .\\ u)) Unconstrained1) => VarF v x -> Either (VarF u x) (VarF (v .\\ u) x)

-- | Like <a>erase</a> but specialised for <a>VarF</a>.
eraseF :: forall c r x b. Forall (ApplyRow x r) c => (forall a. c a => a -> b) -> VarF r x -> b

-- | Like <a>eraseWithLabels</a> but specialised for <a>VarF</a>.
eraseWithLabelsF :: forall c r x s b. (Forall (ApplyRow x r) c, IsString s) => (forall a. c a => a -> b) -> VarF r x -> (s, b)

-- | Like <a>caseon</a> but specialised for <a>VarF</a>.
caseonF :: (Switch (ApplyRow x v) r y) => Rec r -> VarF v x -> y

-- | Like <a>switch</a> but specialised for <a>VarF</a>.
switchF :: (Switch (ApplyRow x v) r y) => VarF v x -> Rec r -> y


-- | This module defines the <a>OpenADT</a> type, which is an algebraic
--   data type with constructors defined by its argument's row type.
module Data.OpenADT

-- | A algebraic data type that can have constructors added and removed.
type OpenADT r = Fix (VarF r)
