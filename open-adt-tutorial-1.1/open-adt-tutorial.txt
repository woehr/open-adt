-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Open algebraic data type examples.
--   
--   Example usage of open-adt with haddock documentation. Read the
--   <a>Data.OpenADT.Tutorial</a> module from top to bottom.
@package open-adt-tutorial
@version 1.1


-- | Description : A short tutorial with code.
module Data.OpenADT.Tutorial

-- | A type alias to reduce typing when writing the types of algebras.
type Alg f x = f x -> x

-- | The base case of a list type.
data NilF x
NilF' :: NilF x

-- | A one element cons element.
data Cons1F a x
Cons1F' :: a -> x -> Cons1F a x

-- | A two element cons element.
data Cons2F a x
Cons2F' :: a -> a -> x -> Cons2F a x

-- | The row of the first list type. It defines a "standard" list type.
type List1RowF a = ("nilF" .== NilF .+ "cons1F" .== Cons1F a)

-- | The row of the second list type. This type re-uses the constructors of
--   <a>List1RowF</a> and includes a third constructor: a two element cons.
type List2RowF a = List1RowF a .+ ("cons2F" .== Cons2F a)

-- | The base functor of the <a>List1</a> type. It is a <a>VarF</a> with
--   the row <a>List1RowF</a>.
type List1F a = VarF (List1RowF a)

-- | A list type. We obtain this type by taking the fixed point of its base
--   functor.
type List1 a = Fix (VarF (List1RowF a))

-- | The base functor of the <a>List2</a> type.
type List2F a = VarF (List2RowF a)

-- | A list type with a two element cons. This type is defined with the
--   <a>OpenADT</a> synonym, which is simply conveinience for <tt>Fix (VarF
--   r)</tt>.
type List2 a = OpenADT (List2RowF a)

-- | Construct a <a>List1</a>. The patterns <a>Cons1</a> and <a>Nil</a> are
--   used.
--   
--   <pre>
--   &gt;&gt;&gt; print exList1
--   Fix (VarF (Cons1F' 0 (Fix (VarF (Cons1F' 1 (Fix (VarF NilF')))))))
--   </pre>
exList1 :: List1 Int

-- | Construct a <a>List2</a>.
--   
--   <pre>
--   &gt;&gt;&gt; print exList2
--   Fix (VarF (Cons2F' 2 3 (Fix (VarF (Cons1F' 4 (Fix (VarF NilF')))))))
--   </pre>
exList2 :: List2 Int

-- | The constructor <a>Cons2F</a> is added to <a>exList1</a> without
--   changing its structure.
--   
--   <pre>
--   &gt;&gt;&gt; print result1
--   Fix (VarF (Cons1F' 0 (Fix (VarF (Cons1F' 1 (Fix (VarF NilF')))))))
--   </pre>
result1 :: List2 Int

-- | Remove a constructor using <a>reduceVarF</a> to convert a <a>List2</a>
--   to a <a>List1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; print result2
--   Fix (VarF (Cons1F' 2 (Fix (VarF (Cons1F' 3 (Fix (VarF (Cons1F' 4 (Fix (VarF NilF'))))))))))
--   </pre>
result2 :: List1 Int

-- | Use "traditional" pattern matching to write an algebra over a
--   <a>List1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; print result3
--   Fix (VarF (Cons2F' 0 0 (Fix (VarF (Cons2F' 1 1 (Fix (VarF NilF')))))))
--   </pre>
result3 :: List2 Int

-- | An alternative way of writing <a>result3</a> using <a>caseonF</a>.
--   
--   <pre>
--   &gt;&gt;&gt; print result4
--   Fix (VarF (Cons2F' 0 0 (Fix (VarF (Cons2F' 1 1 (Fix (VarF NilF')))))))
--   </pre>
result4 :: List2 Int

-- | This type class defines a fmap-like operation over lists.
class OverList a a' r (f :: * -> *)
fmapList' :: OverList a a' r f => (a -> a') -> f (OpenADT r) -> OpenADT r

-- | Apply the <a>fmapList'</a> function to any <tt>(OpenADT r)</tt>
--   provided all its constructors satisfy the constraint <tt>(OverList a
--   a' s)</tt>.
fmapList :: forall a a' r s. (Forall r Functor, Forall r (OverList a a' s)) => (a -> a') -> OpenADT r -> OpenADT s

-- | Demonstrate that <a>fmapList</a> can be applied to <a>exList1</a>.
--   
--   <pre>
--   result5 = fmapList (show @Int) exList1 :: List1 String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; print result5
--   Fix (VarF (Cons1F' "0" (Fix (VarF (Cons1F' "1" (Fix (VarF NilF')))))))
--   </pre>
result5 :: List1 String

-- | Demonstrate that <a>fmapList</a> can be applied to <a>exList2</a>.
--   
--   <pre>
--   result6 = fmapList (show @Int) exList2 :: List2 String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; print result6
--   Fix (VarF (Cons2F' "2" "3" (Fix (VarF (Cons1F' "4" (Fix (VarF NilF')))))))
--   </pre>
result6 :: List2 String

-- | Demonstrate how to handle subsets of a <a>VarF</a> individually.
--   
--   Below is an alternate, but identical, implementation for the case
--   where one subset of variants matched is a single variant
--   (<a>trialF</a> is used instead of <a>multiTrialF</a>).
--   
--   <pre>
--   result7 = <a>cata</a> alg exList2 where
--     alg w = case <a>trialF</a> w #cons2F of
--       Left (Cons2F' a b x) -&gt; Cons1 ("(" &lt;&gt; show a &lt;&gt; " : " &lt;&gt; show b &lt;&gt; ")") x
--       Right leftovers -&gt; <a>fmapList'</a> (show @Int) leftovers
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; print result7
--   Fix (VarF (Cons1F' "(2 : 3)" (Fix (VarF (Cons1F' "4" (Fix (VarF NilF')))))))
--   </pre>
result7 :: List1 String

-- | This is the function invoked by the executable in this package. It
--   simply prints out the examples.
main' :: IO ()
instance Data.OpenADT.VarF.OpenAlg r "nilF" Data.OpenADT.Tutorial.NilF (Data.OpenADT.OpenADT r) => Data.OpenADT.Tutorial.OverList a a' r Data.OpenADT.Tutorial.NilF
instance Data.OpenADT.VarF.OpenAlg r "cons1F" (Data.OpenADT.Tutorial.Cons1F a') (Data.OpenADT.OpenADT r) => Data.OpenADT.Tutorial.OverList a a' r (Data.OpenADT.Tutorial.Cons1F a)
instance Data.OpenADT.VarF.OpenAlg r "cons2F" (Data.OpenADT.Tutorial.Cons2F a') (Data.OpenADT.OpenADT r) => Data.OpenADT.Tutorial.OverList a a' r (Data.OpenADT.Tutorial.Cons2F a)
instance Data.Row.Internal.Forall v (Data.OpenADT.Tutorial.OverList a a' r) => Data.OpenADT.Tutorial.OverList a a' r (Data.OpenADT.VarF.VarF v)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.OpenADT.Tutorial.Cons2F a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.OpenADT.Tutorial.Cons1F a)
instance Data.Functor.Classes.Show1 Data.OpenADT.Tutorial.NilF
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.OpenADT.Tutorial.Cons2F a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.OpenADT.Tutorial.Cons1F a)
instance Data.Functor.Classes.Ord1 Data.OpenADT.Tutorial.NilF
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.OpenADT.Tutorial.Cons2F a)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.OpenADT.Tutorial.Cons1F a)
instance Data.Functor.Classes.Eq1 Data.OpenADT.Tutorial.NilF
instance (GHC.Show.Show a, GHC.Show.Show x) => GHC.Show.Show (Data.OpenADT.Tutorial.Cons2F a x)
instance (GHC.Classes.Ord a, GHC.Classes.Ord x) => GHC.Classes.Ord (Data.OpenADT.Tutorial.Cons2F a x)
instance GHC.Base.Functor (Data.OpenADT.Tutorial.Cons2F a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq x) => GHC.Classes.Eq (Data.OpenADT.Tutorial.Cons2F a x)
instance (GHC.Show.Show a, GHC.Show.Show x) => GHC.Show.Show (Data.OpenADT.Tutorial.Cons1F a x)
instance (GHC.Classes.Ord a, GHC.Classes.Ord x) => GHC.Classes.Ord (Data.OpenADT.Tutorial.Cons1F a x)
instance GHC.Base.Functor (Data.OpenADT.Tutorial.Cons1F a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq x) => GHC.Classes.Eq (Data.OpenADT.Tutorial.Cons1F a x)
instance GHC.Show.Show (Data.OpenADT.Tutorial.NilF x)
instance GHC.Classes.Ord (Data.OpenADT.Tutorial.NilF x)
instance GHC.Base.Functor Data.OpenADT.Tutorial.NilF
instance GHC.Classes.Eq (Data.OpenADT.Tutorial.NilF x)
